#!/usr/bin/env python2

###Flight simulator. 
#Write a code in python that simulates the tilt correction of the plane (angle between plane wings and earth). 
##The program should:
# - print out current orientation
# - applied tilt correction
# - run in infinite loop
# - until user breaks the loop
#Assume that plane orientation in every new simulation step is random angle with gaussian distribution (the planes is experiencing "turbulations"). 
#With every simulation step the orentation should be corrected, applied and printed out.
#If you can thing of any other features, you can add them.
#This code shoud be runnable with 'python kol1.py'.
#If you have spare time you can implement: Command Line Interface, generators, or even multiprocessing.
#Do your best, show off with good, clean, well structured code - this is more important than number of features.
#After you finish, be sure to UPLOAD this (add, commit, push) to the remote repository.
#Good Luck


#will generate random angles from normal distribution around 0.0
#	with st.dev of 30 deg.
#fix will be applied analogously, with the mean at -angle and st.dev of 5.0

from __future__ import division
from math import fabs
from random import gauss
from time import sleep

class Turbulence:
	"""Describes wind effect on an airplane as the roll angle
	(the angle between the wings and the horizontal plane)
	"""
	
	def __init__(self,st_dev=30.0):
		"""An instance is created for use in the Airplane class.
		Input argument: st_dev describes the standard deviation
		of roll tilt applied to an airplane, generated through
		gaussian distribution centered on 0.0.
		The results of previous tilt values are stored in list
		self.tilt_backlog up to 100 steps back.
		"""
		self.tilt_backlog = []
		self.st_dev = st_dev
	
	def get_new_tilt(self):
		"""Generates a new tilt value based on saved standard deviation,
		saves recent results up to 100 steps back, returns the new one.
		"""
		tilt = gauss(0.0,self.st_dev)
		self.tilt_backlog.append(tilt)
		if len(self.tilt_backlog) > 100:
			del self.tilt_backlog[0]
		return tilt

class Airplane:
	"""A simplified representation of the simulated state of an airplane.
	Designed with use inside iteration loops.
	The parameter of the airplane being simulated is the roll
	(angle between the wings and the horizontal plane).
	The roll is affected by the wind generated by a Turbulence instance
	and by simulated pilot response, compensating for the tilt with
	imperfect effectiveness.
	"""
	
	def __init__(self,wind_st_dev=30.0,pilot_st_dev=5.0):
		"""An instance is created taking two arguments:
		wind_st_dev: passed on for the instance of Turbulence,
			as the standard deviation for the random wind tilt
		pilot_st_dev: gauges the response accuracy for compensation
			for the wind-based tilt
		The accuracy of response is saved up to 100 steps back
		in the self.correction_backlog list.
		The final roll angle value at the end of an iteration step
		is saved in self.roll_backlog up to 100 steps back as well.
		"""
		self.wind = Turbulence(wind_st_dev)
		self.pilot_st_dev = pilot_st_dev
		self.roll_backlog = [ 0.0 ]
		self.correction_backlog = []
		self.starting_roll = 0.0
		self.current_roll = 0.0
		self.iteration = 0
	
	def print_status(self):
		"""Prints the full outcome of an iteration step.
		"""
		print 'Step {0:d}'.format(self.iteration)
		print 'Initial roll: {0:2.3f} degrees'.format(self.starting_roll)
		print 'Turbulence change: {0:2.3f}'.format(self.wind.tilt_backlog[-1])
		print 'Compensation: {0:2.1f} %'.format(self.correction_backlog[-1])
		print 'Final roll: {0:2.3f} degrees'.format(self.current_roll)
		
	def apply_wind(self):
		"""Generates a tilt value through Turbulence.get_new_tilt()
		and applies it to the current status of the airplane.
		"""
		tilt = self.wind.get_new_tilt()
		self.current_roll += tilt
	
	def get_compensation(self):
		"""Applies a pilot compensation tilt to the airplane state.
		The absolute value of a compensating tilt is generated from
		a gaussian distribution around self.current_roll value with
		the standard deviation of self.pilot_st_dev.
		"""
		fix = gauss(-self.current_roll,self.pilot_st_dev)
		self.correction_backlog.append(fabs(fix/self.current_roll)*100)
		if len(self.correction_backlog) > 100:
			del self.correction_backlog[0]
		self.current_roll += fix
	
	def run_iteration(self):
		"""The method encompassing all of the simulation's functions
		to be done during an iteration step.
		The wind tilt is added (through self.apply_wind()), then the
		pilot correction is included (through self.get_compensation()),
		finally the result of the step is printed to the console.
		"""
		self.iteration += 1
		self.starting_roll = self.roll_backlog[-1]
		self.apply_wind()
		self.get_compensation()
		self.roll_backlog.append(self.current_roll)
		if len(self.roll_backlog) > 100:
			del self.roll_backlog[0]
		self.print_status()
		

if __name__=='__main__':
	print 'Simple flight simulation.\n'
	print 'Input standard deviation for wind tilt (default: 30.0 deg)'
	wind_stdev = 30.0
	user_input_wind_stdev = raw_input()
	if user_input_wind_stdev:
		try:
			wind_stdev = float(user_input_wind_stdev)
		except ValueError:
			print 'Incorrect input. Setting the value to default.\n'
	
	print 'Input standard deviation for pilot correction (default: 5.0 deg)'
	pilot_stdev = 5.0
	user_input_pilot_stdev = raw_input()
	if user_input_pilot_stdev:
		try:
			pilot_stdev = float(user_input_pilot_stdev)
		except ValueError:
			print 'Incorrect input. Setting the value to default.\n'
	
	airplane = Airplane(wind_stdev,pilot_stdev)
	
	print 'All ready. Starting simulation.\n'
	sleep(1)
	
	try:
		while True:
			airplane.run_iteration()
			sleep(2)
	except KeyboardInterrupt:
		print '\nProgram stopped.'
		sleep(0.5)
		print 'Final simulation status:'
		sleep(0.5)
		airplane.print_status()

#Jakub Ahaddad
#github username ahdyqb
